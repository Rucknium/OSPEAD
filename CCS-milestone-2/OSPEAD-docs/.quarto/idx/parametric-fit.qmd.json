{"title":"Parametric Fit","markdown":{"headingText":"Parametric Fit","headingAttr":{"id":"sec-parametric-fit","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nHaving estimated the nonparametric PMF, we now need to fit a parametric distribution.\n\nFirst, the weekly PMFs must be aggregated. The value of the weekly PMFs at each support point can simply be averaged. Some weeks are excluded because of data availability problems or exogenous shocks:\n\n- No txpool data for weeks 2023-13 and 2023-14\n- Volatility caused by Binance Monitoring Tag during weeks 2023-51, 2023-52, 2024-01, and 2024-02\n- Binance delisting during week 2024-06\n- Suspected black marble spam during weeks 2024-09, 2024-10, 2024-11, 2024-12, 2024-13, 2024-14, 2024-15, and 2024-16\n- Failure to estimate for unknown reasons for week 2024-19\n\nAs stated in @sec-nonparametric-real-spend-mixing-proportions , the mixing proportion of the second-largest component distribution was estimated to be much larger during some of the exogenous events, suggesting inappropriate splitting of the `wallet2` ring distribution. In theory, the first and second estimated components could be re-combined by computing their weighted sum, with the estimated mixing proportions as their weights. The simpler solution is to exclude these weeks as anomalous, which is what I have done.\n\n## Objective function\n\nUsually, fitting a parametric distribution to nonparametric data involves minimization or maximization of an objective function by adjusting the parametric distribution's parameters until the best fit is achieved. In OSPEAD, the new decoy parametric probability distribution will be chosen by minimizing the probability that the Maximum A Posteriori (MAP) Decoder Attack described by @Aeeneh2021 is successful. Let $Z$ be the total number of outputs eligible to be spent in a RingCT ring. Let $f_S$ be the real spend probability mass function (PMF). Let $f_D$ be a proposed decoy PMF. Let $\\mathbf{1}\\{\\}$ be the indicator function that takes value 1 when the statement within the braces is true and 0 otherwise. The average success probability of the MAP Decoder attack is\n\n\n$$\nL_{MAP\\:Decoder}=\\sum_{i=1}^{Z}f_{S}\\left(i\\right)\\left(\\sum_{j=1}^{Z}f_{D}\\left(j\\right)\\mathbf{1}\\left\\{ \\tfrac{f_{S}\\left(j\\right)}{f_{D}\\left(j\\right)}<\\tfrac{f_{S}\\left(i\\right)}{f_{D}\\left(i\\right)}\\right\\} \\right)^{M}\n$$ {#eq-map-decoder-simple}\n\n\nThe $f_{S}\\left(i\\right)$ weights the attack success probability by the probability mass at the $i$th output. Very old outputs are rarely spent, so they are given low weight. @eq-map-decoder-simple can be modified to give more weight to old outputs. The $f_{S}\\left(i\\right)$ weight can be changed into a convex combination of $f_{S}\\left(i\\right)$ and giving each output an equal weight, parameterized by $\\lambda$: $\\left(\\lambda f_{S}\\left(i\\right)+(1-\\lambda)\\frac{1}{Z}\\right)$. The more general objective function is\n\n\n$$\nL_{MAP\\:Decoder}(\\lambda)=\\sum_{i=1}^{Z}\\left(\\lambda f_{S}\\left(i\\right)+(1-\\lambda)\\frac{1}{Z}\\right)\\sum_{j=1}^{Z}\\left(f_{D}\\left(j\\right)\\mathbf{1}\\left\\{ \\tfrac{f_{S}\\left(j\\right)}{f_{D}\\left(j\\right)}<\\tfrac{f_{S}\\left(i\\right)}{f_{D}\\left(i\\right)}\\right\\} \\right)^{M}\n$$ {#eq-map-decoder-lambda}\n\n\nWe shall use $\\lambda=1$ and $\\lambda=0.5$.\n\n## Parametric distributions {#sec-parametric-distributions}\n\nThe following parametric distributions will be fit:\n\n- [Gamma](https://en.wikipedia.org/wiki/Gamma_distribution)\n- [Non-central F](https://en.wikipedia.org/wiki/Noncentral_F-distribution)\n- Right-Pareto Lognormal (RPLN) [@ReedJorgensen2004]\n- [Generalized Extreme Value (GEV)](https://en.wikipedia.org/wiki/Generalized_extreme_value_distribution)\n- [Birnbaum-Saunders (BS)](https://en.wikipedia.org/wiki/Birnbaum%E2%80%93Saunders_distribution)\n- [Generalized Beta of the Second Kind (GB2)](https://en.wikipedia.org/wiki/Generalized_beta_distribution#Generalized_beta_of_the_second_kind_(GB2))\n\nEach distribution will be fitted on the raw nonparametric distribution and a log transformation of it.\n\n## Implementation details\n\n### Computational expense\n\nNotice the double summation over $Z$ in @eq-map-decoder-simple . $Z$ is over 100 million. A naive implementation of @eq-map-decoder-simple would require over 10 quadrillion comparisons. Furthermore, @eq-map-decoder-simple needs to be evaluated several hundred times during the numerical optimization algorithm. The computational issues were handled by:\n\n1) Developing a fast implementation of @eq-map-decoder-simple that leverages sorting logic. The implementation is in the code section as `map.decoder.success.prob()` below.\n\n2) Selecting only 10 percent of all outputs as a sample instead of the entire population. The probability of the $i$th output being selected is proportional to the probability mass $f_S(i)$. About 96 percent of the total probability mass is included because high-probability outputs are more likely to be selected.\n\n### Excess tail penalty\n\nDuring fitting, the probability mass that is older than the oldest output is added back to the rest of the probability distribution. This procedure reflects the fact that a wallet would re-draw a random output that is older than the oldest RingCT output. During fitting, I sometimes observed excessive \"flattening\" of the probability distribution where the portion of the distribution that extended past the oldest output exceeded 70 percent. There was a need to discourage the optimizer from flattening the distribution.\n\nI added an excess tail penalty. When 10 percent or more of the distribution's mass extends past the oldest output, a proportional penalty is added to the optimizer's objective function.\n\n### Parameter initial values\n\nI use the [Nelder-Mead algorithm](https://en.wikipedia.org/wiki/Nelder%E2%80%93Mead_method) to minimize the objective functions. Nelder-Mead, like most optimization algorithms, needs initial parameter values to start the optimization procedure. The starting values are obtained by drawing 10,000 observations from the real spend distribution and estimating the appropriate maximum likelihood model parameter estimates. Of course, the maximum likelihood methods need starting values. See the documentation of the maximum likelihood R functions in the code below for details. There was no automatic method to select starting values for the noncentral F distribution. In that case, I manually specified reasonable starting values.\n\n## Code {#sec-parametric-fit-code}\n\nThis code can be run in a new R session. It may take a day or two to run on a powerful machine.\n\n\n```{r}\n#| column: page\n\n\nlibrary(data.table)\n\n\nresults.dir <- \"results\"\n\n\nexcl.weeks <- c(\"2023-13.qs\", \"2023-14.qs\", \"2023-51.qs\", \"2023-52.qs\", \"2024-01.qs\", \"2024-02.qs\",\n  \"2024-06.qs\", \"2024-09.qs\", \"2024-10.qs\", \"2024-11.qs\", \"2024-12.qs\", \"2024-13.qs\", \"2024-14.qs\",\n  \"2024-15.qs\", \"2024-16.qs\", \"2024-17.qs\", \"2024-19.qs\")\n\nlambda.params <- c(1, 0.5)\n\n\nresults.dir.run <- paste0(results.dir, \"/results-01/\")\n\n\nnonparametric.real.spend <- qs::qread(file = paste0(results.dir.run, \"nonparametric-real-spend.qs\"))\n\nnonparametric.real.spend <- nonparametric.real.spend$rucknium\n\n\nweekly.real.spend.cdfs <- nonparametric.real.spend$weekly.real.spend.cdfs\n\nall.weeks.weighted.v.mean <- nonparametric.real.spend$all.weeks.weighted.v.mean\n\nweighted.v.mean <- mean(all.weeks.weighted.v.mean)\n\nsupport.max <- nonparametric.real.spend$support.max\n\n\n\nall.weeks.weighted.v.mean <- all.weeks.weighted.v.mean[! names(all.weeks.weighted.v.mean) %in% excl.weeks]\n\naggregate.real.spend.pmf <- diff(weekly.real.spend.cdfs[[1]](as.numeric(0:(support.max + 1))))\n\nfor (week in setdiff(names(weekly.real.spend.cdfs)[-1], excl.weeks)) {\n  cat(week, \"\\n\")\n  aggregate.real.spend.pmf <- aggregate.real.spend.pmf +\n    diff(weekly.real.spend.cdfs[[week]](as.numeric(0:(support.max + 1))))\n}\n\naggregate.real.spend.pmf <- aggregate.real.spend.pmf/sum(aggregate.real.spend.pmf)\n\nstopifnot(all.equal(1, sum(aggregate.real.spend.pmf)))\n\n\n\n\nget.decoy.pmf <- function(cdf, v, z, sub.supp, log.trans = FALSE, ...) {\n  \n  G <- function(x) {\n    cdf(x, ...)\n  }\n  \n  if (log.trans) {\n    G_star <- function(x) {\n      G(log1p(x*v))/G(log1p(z*v))\n    }\n  } else {\n    G_star <- function(x) {\n      G(x*v)/G(z*v)\n    }\n  }\n  \n  G_star(sub.supp) - G_star(sub.supp - 1)\n  \n}\n\n\n\n\n\nparam.trans <- list()\n\nf_D.lgamma <- function(param, v, z, sub.supp, get.decoy.pmf) {\n  list(decoy.pmf =  get.decoy.pmf(actuar::plgamma, v, z, sub.supp = sub.supp, shapelog = exp(param[1]), ratelog = exp(param[2])),\n    tail.beyond.support = 1 - actuar::plgamma(z*v, shapelog = exp(param[1]), ratelog = exp(param[2])))\n}\n\nparam.trans$lgamma <- c(exp, exp)\n\nf_D.gamma <- function(param, v, z, sub.supp, get.decoy.pmf, log.trans) {\n  list(decoy.pmf =  get.decoy.pmf(stats::pgamma, v, z, sub.supp = sub.supp, log.trans = log.trans, shape = exp(param[1]), rate = exp(param[2])),\n    tail.beyond.support = 1 - stats::pgamma(ifelse(log.trans, log1p(z*v), z*v), shape = exp(param[1]), rate = exp(param[2])))\n}\n\nparam.trans$gamma <- c(exp, exp)\n\n\nf_D.f <- function(param, v, z, sub.supp, get.decoy.pmf, log.trans) {\n  list(decoy.pmf =  get.decoy.pmf(cdf = stats::pf, v, z, sub.supp, log.trans = log.trans, df1 = exp(param[1]), df2 = exp(param[2]), ncp = exp(param[3])),\n    tail.beyond.support = 1 - stats::pf(ifelse(log.trans, log1p(z*v), z*v),  df1 = exp(param[1]), df2 = exp(param[2]), ncp = exp(param[3])))\n}\n\nparam.trans$f <- c(exp, exp, exp)\n\n\nf_D.rpln <- function(param, v, z, sub.supp, get.decoy.pmf, log.trans, return.log = FALSE, ...) {\n  list(decoy.pmf =  get.decoy.pmf(distributionsrd::prightparetolognormal, v, z, sub.supp, log.trans = log.trans, shape2 = exp(param[1]),\n    meanlog = param[2], sdlog = exp(param[3]), lower.tail = TRUE, log.p = FALSE),\n    tail.beyond.support = 1 - distributionsrd::prightparetolognormal(ifelse(log.trans, log1p(z*v), z*v), shape2 = exp(param[1]), meanlog = param[2], sdlog = exp(param[3]), lower.tail = TRUE, log.p = FALSE))\n}\n\n\nparam.trans$rpln <- c(exp, I, exp)\n\nf_D.gev <- function(param, v, z, sub.supp, get.decoy.pmf, log.trans) {\n  list(decoy.pmf =  get.decoy.pmf(VGAM::pgev, v, z, sub.supp = sub.supp, log.trans = log.trans, location = param[1], scale = exp(param[2]), shape = param[3]),\n    tail.beyond.support = 1 - VGAM::pgev(ifelse(log.trans, log1p(z*v), z*v), location = param[1], scale = exp(param[2]), shape = param[3]))\n}\n\nparam.trans$gev <- c(I, exp, I)\n\n\nf_D.bs <- function(param, v, z, sub.supp, get.decoy.pmf, log.trans) {\n  list(decoy.pmf =  get.decoy.pmf(cdf = bsgof::pbs, v, z, sub.supp, log.trans = log.trans, alpha = exp(param[1]), beta = exp(param[2])),\n    tail.beyond.support = 1 - bsgof::pbs(ifelse(log.trans, log1p(z*v), z*v), alpha = exp(param[1]), beta = exp(param[2])))\n}\n\nparam.trans$bs <- c(exp, exp)\n\n\n\nf_D.gb2 <- function(param, v, z, sub.supp, get.decoy.pmf, log.trans) {\n  list(decoy.pmf =  get.decoy.pmf(cdf = GB2::pgb2, v, z, sub.supp, log.trans = log.trans, shape1 = exp(param[1]), scale = exp(param[2]), shape2 = exp(param[3]), shape3 = exp(param[4])),\n    tail.beyond.support = 1 - GB2::pgb2(ifelse(log.trans, log1p(z*v), z*v), shape1 = exp(param[1]), scale = exp(param[2]), shape2 = exp(param[3]), shape3 = exp(param[4])))\n}\n\nparam.trans$gb2 <- c(exp, exp, exp, exp)\n\n\nmap.decoder.success.prob <- function(f_S, f_D) {\n  # This implementation assumes that every output selected in a ring\n  # is unique (i.e. does not handle multi-output aggregates like \n  # pseudo-blocks). The inequality comparison is strict.\n  \n  cut.vector <- f_S/f_D\n  rm(f_S)\n  names(cut.vector) <- as.character(1:length(cut.vector))\n  \n  y <- data.table(f_D = f_D, cut.vector.var = cut.vector)\n  \n  setorder(y, cut.vector.var)\n  \n  cut.vector <- sort(cut.vector)\n  cut.vector.unique <- cut.vector[!duplicated(cut.vector)]\n  # Using duplicated() keeps names. unique() does not keep names.\n  cut.vector.name.unique <- as.integer(names(cut.vector.unique))\n  \n  y[, cut.vector.cut := cut.vector.name.unique[ .bincode(cut.vector.var, c(-1, cut.vector.unique), right = FALSE)] ]\n  \n  setorder(y, cut.vector.var)\n  y[, cut.vector.var := NULL]\n  \n  y[, f_D := cumsum(f_D)]\n  rm(f_D)\n  y <- y[, .(success.prob = f_D[.N]), by = cut.vector.cut]\n  \n  y <- merge(y, data.table(cut.vector.cut = cut.vector.name.unique, cut.vector = cut.vector.unique))\n  rm(cut.vector.name.unique)\n  y[, cut.vector.cut := NULL]\n  \n  y <- merge(y, data.table(cut.vector.cut.names = as.integer(names(cut.vector)), cut.vector = unname(cut.vector)),\n    all = TRUE, by = \"cut.vector\")\n  y[, cut.vector := NULL]\n  setorder(y, cut.vector.cut.names)\n  y[, cut.vector.cut.names := NULL]\n  \n  setDF(y)\n  \n  y$success.prob[is.na(y$success.prob)] <- 0\n  # At the point(s) where f_S/f_D is at a minimum, the attack would always\n  # choose another block height, so the attack success probability is zero\n  \n  y <- y$success.prob\n  \n  # gc()\n  \n  y\n  \n}\n\n\nL_Attack <- function(param, f_D, v, z, sub.supp, theta_i, get.decoy.pmf, map.decoder.success.prob, lambda = 1, log.trans) {\n  \n  f_D.return <- f_D(param, v, z, sub.supp, get.decoy.pmf, log.trans)\n  \n  a_i <- f_D.return$decoy.pmf\n  tail.penalty <- f_D.return$tail.beyond.support\n  rm(f_D.return)\n  \n  if (any(! is.finite(a_i))) { return(1) }\n  a_i[a_i <= 0] <- .Machine$double.eps\n  \n  values.map.decoder.success.prob <- map.decoder.success.prob(f_S = theta_i/sum(theta_i), f_D = a_i/sum(a_i))\n  \n  n.decoys <- 15\n  \n  cat(round(tail.penalty, 5), \"<>\")\n  tail.penalty <- tail.penalty - 0.10 # 0.05\n  \n  if (tail.penalty <= 0) {tail.penalty <- 0}\n  \n  stopifnot(length(values.map.decoder.success.prob) == length(theta_i))\n  \n  weight <- lambda * (theta_i/sum(theta_i)) + (1 - lambda) * 1/length(theta_i)\n  \n  sum(weight * (values.map.decoder.success.prob)^n.decoys) + tail.penalty\n  \n}\n\n\ntheta_i <- aggregate.real.spend.pmf\ntheta_i[theta_i == 0] <- .Machine$double.eps\n\nz <- length(theta_i)\nv <- mean(all.weeks.weighted.v.mean)\n\nset.seed(314)\nsub.supp <- wrswoR::sample_int_expj(length(theta_i), ceiling(length(theta_i)/10), prob = theta_i)\n# wrswoR::sample_int_expj is much faster than sample() when the prob vector is long\n# start at 2 so G(x - 1) is not 0\nsub.supp <- sort(sub.supp)\ntheta_i <- theta_i[sub.supp]\n\n\ngen.data <- stepfun( cumsum(theta_i/sum(theta_i)), c(0, as.numeric(sub.supp)) )\n\n\nmle.generated.data <- gen.data(runif(10000))\nmle.generated.data <- mle.generated.data[mle.generated.data > 0]\n\n\ngamma.fit <- Rfast::gammamle(mle.generated.data)\ngamma.fit.coef <- log(gamma.fit$param)\n\ngamma.fit <- Rfast::gammamle(log1p(mle.generated.data))\ngamma.fit.coef.log <- log(gamma.fit$param)\n\n\nf.fit <- fitdistrplus::fitdist(mle.generated.data, \"f\", method = \"mle\", start = list(df1 = exp(-1), df2 = exp(0), ncp = exp(2)))\nf.fit.coef <- log(coef(f.fit))\n\nf.fit <- fitdistrplus::fitdist(log1p(mle.generated.data), \"f\", method = \"mle\", start = list(df1 = exp(-1), df2 = exp(0), ncp = exp(2)))\nf.fit.coef.log <- log(coef(f.fit))\n\n\nrpln.fit <- distributionsrd::rightparetolognormal.mle(mle.generated.data)\nrpln.fit.coef <- c(log(rpln.fit$coefficients[[\"shape2\"]]), rpln.fit$coefficients[[\"meanlog\"]],\n  log(rpln.fit$coefficients[[\"sdlog\"]]) )\n\nrpln.fit <- distributionsrd::rightparetolognormal.mle(log1p(mle.generated.data))\nrpln.fit.coef.log <- c(log(rpln.fit$coefficients[[\"shape2\"]]), rpln.fit$coefficients[[\"meanlog\"]],\n  log(rpln.fit$coefficients[[\"sdlog\"]]) )\n\n\ngev.fit <- VGAM::vglm(mle.generated.data ~ 1, VGAM::gevff, control = VGAM::vglm.control(maxit = 1000, trace = TRUE))\ngev.fit.coef <- VGAM::Coef(gev.fit)\ngev.fit.coef[2] <- log(gev.fit.coef[2])\n\ngev.fit <- VGAM::vglm(log1p(mle.generated.data) ~ 1, VGAM::gevff, control = VGAM::vglm.control(maxit = 1000, trace = TRUE))\ngev.fit.coef.log <- VGAM::Coef(gev.fit)\ngev.fit.coef.log[2] <- log(gev.fit.coef.log[2])\n\n\nbs.fit <- bsgof::bs.mle(mle.generated.data)\nbs.fit.coef <- log(c(bs.fit$alpha, bs.fit$beta))\n\nbs.fit <- bsgof::bs.mle(log1p(mle.generated.data))\nbs.fit.coef.log <- log(c(bs.fit$alpha, bs.fit$beta))\n\ngb2.fit <- GB2::mlfit.gb2(mle.generated.data)\ngb2.fit.coef <- log(gb2.fit[[2]]$par)\n\ngb2.fit <- GB2::mlfit.gb2(log1p(mle.generated.data + 1))\ngb2.fit.coef.log <- log(gb2.fit[[2]]$par)\n\n\nrun.iters.simple <- expand.grid(\n  f_D = c(\n    f_D.gamma = f_D.gamma,\n    f_D.f = f_D.f,\n    f_D.rpln = f_D.rpln,\n    f_D.gev = f_D.gev,\n    f_D.bs = f_D.bs,\n    f_D.gb2 = f_D.gb2\n  ),\n  flavor = 1,\n  week = 0,\n  est.method = 0,\n  L = c(L_Attack = L_Attack),\n  lambda = lambda.params,\n  log.trans = c(FALSE, TRUE)\n)\n\n\n\nstart.params <- list(\n  f_D.gamma = list(no.log = gamma.fit.coef, log = gamma.fit.coef.log),\n  f_D.f = list(no.log = f.fit.coef, log = f.fit.coef.log),\n  f_D.rpln = list(no.log = rpln.fit.coef, log = rpln.fit.coef.log),\n  f_D.gev = list(no.log = gev.fit.coef, log = gev.fit.coef.log),\n  f_D.bs = list(no.log = bs.fit.coef, log = bs.fit.coef.log),\n  f_D.gb2 = list(no.log = gb2.fit.coef, log = gb2.fit.coef.log))\n\n\n\n\n\nthreads <- floor(nrow(run.iters.simple)/2)\nfuture::plan(future::multisession(workers = threads))\n\nkeep.time <- base::date()\n\nfit.results <- future.apply::future_lapply(1:nrow(run.iters.simple), function(iter) {\n  \n  f_D.fun <- run.iters.simple$f_D[[iter]]\n  L.fun <- run.iters.simple$L[[iter]]\n  flavor <- run.iters.simple$flavor[[iter]]\n  lambda <- run.iters.simple$lambda[[iter]]\n  log.trans <- run.iters.simple$log.trans[[iter]]\n  if (log.trans) {\n    start.params.optim <- start.params[[names(run.iters.simple$f_D[iter])]]$log\n  } else {\n    start.params.optim <- start.params[[names(run.iters.simple$f_D[iter])]]$no.log\n  }\n  \n  \n  optim.results <- optim(\n    start.params.optim,\n    L.fun,\n    f_D = f_D.fun,\n    v = v,\n    z = z,\n    sub.supp = sub.supp,\n    get.decoy.pmf = get.decoy.pmf,\n    map.decoder.success.prob = map.decoder.success.prob,\n    log.trans = log.trans,\n    lambda = lambda, \n    method = \"Nelder-Mead\", \n    control = list(trace = 6, maxit = 10000),\n    theta_i = theta_i)\n  \n  optim.results\n  \n}, future.globals = c(\"run.iters.simple\", \"start.params\", \"v\", \"z\", \"sub.supp\", \"get.decoy.pmf\",\n  \"map.decoder.success.prob\", \"theta_i\", \"lamba.iter\"),\n  future.packages = \"data.table\", future.seed = TRUE)\n\nprint(keep.time)\nbase::date()\n\n\n\n\n\n```","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"gruvbox","html-math-method":"mathml","output-file":"parametric-fit.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","bibliography":["references.bib"],"bibliographystyle":"apa","editor":"visual","theme":"superhero","fig-cap-location":"top"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"parametric-fit.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"bibliographystyle":"apa","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}