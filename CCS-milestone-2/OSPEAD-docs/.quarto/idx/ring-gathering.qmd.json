{"title":"Ring Gathering","markdown":{"headingText":"Ring Gathering","headingAttr":{"id":"sec-ring-gathering","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\nFirst, the data on ring member ages must be collected from the Monero blockchain. This is done by repeated RPC queries to a running instance of `monerod`, the Monero node software.\n\nSeveral parallel processes are spawned to query `monerod`. The number of processes is half of the CPU's threads, minus one.\n\nThe user should specify two variables\n\n-   `current.height`, which is the most recent height that you want to collect data for. This should be the last block in the last day of an [ISO week](https://en.wikipedia.org/wiki/ISO_week_date), by UTC time. Use `https://xmrchain.net` or another block explorer to determine what block number it is.\n\n-   `url.rpc`, which is the URL of the `monerod` RPC. By default, it should be `http://127.0.0.1:18081`.\n\nOpen an R session and run the following code. Do not close the R session after running it. On a powerful machine, it will take about 24 hours to finish.\n\n## Code\n\n```{r}\n#| column: page\n\nlibrary(data.table)\n\ncurrent.height <- NA # 3263496\n# current.height should be the most recent height that you want to collect data for\n\nstopifnot(!is.na(current.height))\n\nblock.heights <- 1220516:current.height\n# 1220516 is hard fork height that allowed the first RingCT transactions\n# https://github.com/monero-project/monero#scheduled-softwarenetwork-upgrades\n\nurl.rpc <- \"http://127.0.0.1:18081\"\n# Set the IP address and port of your node. Should usually be \"http://127.0.0.1:18081\"\n# Data can be pulled from multiple monerod instances. In that case, the blockchains\n# of the multiple monerod instances should be on different storage devices because\n# storage I/O seems to be the bottleneck. Specify multiple instances as:\n# url.rpc <- c(\"http://127.0.0.1:18081\", \"http://127.0.0.1:58081\")\n\n\n\n# Modified from TownforgeR::tf_rpc_curl function\nxmr.rpc <- function(\n    url.rpc = \"http://127.0.0.1:18081/json_rpc\",\n  method = \"\",\n  params = list(),\n  userpwd = \"\",\n  num.as.string = FALSE,\n  nonce.as.string = FALSE,\n  keep.trying.rpc = FALSE,\n  curl = RCurl::getCurlHandle(),\n  ...\n){\n\n  json.ret <- RJSONIO::toJSON(\n    list(\n      jsonrpc = \"2.0\",\n      id = \"0\",\n      method = method,\n      params = params\n    ), digits = 50\n  )\n\n  rcp.ret <- \ttryCatch(RCurl::postForm(url.rpc,\n    .opts = list(\n      userpwd = userpwd,\n      postfields = json.ret,\n      httpheader = c('Content-Type' = 'application/json', Accept = 'application/json')\n      # https://stackoverflow.com/questions/19267261/timeout-while-reading-csv-file-from-url-in-r\n    ),\n    curl = curl\n  ), error = function(e) {NULL})\n\n  if (keep.trying.rpc && length(rcp.ret) == 0) {\n    while (length(rcp.ret) == 0) {\n      rcp.ret <- \ttryCatch(RCurl::postForm(url.rpc,\n        .opts = list(\n          userpwd = userpwd,\n          postfields = json.ret,\n          httpheader = c('Content-Type' = 'application/json', Accept = 'application/json')\n          # https://stackoverflow.com/questions/19267261/timeout-while-reading-csv-file-from-url-in-r\n        ),\n        curl = curl\n      ), error = function(e) {NULL})\n    }\n  }\n\n  if (is.null(rcp.ret)) {\n    stop(\"Cannot connect to monerod. Is monerod running?\")\n  }\n\n  if (num.as.string) {\n    rcp.ret <- gsub(\"(: )([-0123456789.]+)([,\\n\\r])\", \"\\\\1\\\"\\\\2\\\"\\\\3\", rcp.ret )\n  }\n\n  if (nonce.as.string & ! num.as.string) {\n    rcp.ret <- gsub(\"(\\\"nonce\\\": )([-0123456789.]+)([,\\n\\r])\", \"\\\\1\\\"\\\\2\\\"\\\\3\", rcp.ret )\n  }\n\n  RJSONIO::fromJSON(rcp.ret, asText = TRUE) # , simplify = FALSE\n}\n\n\n\nsystem.time({\n\n  threads <- max(2, min(floor(parallelly::availableCores()/2), 32L) - length(url.rpc))\n\n  future::plan(future::multisession(workers = threads))\n  options(future.globals.maxSize= 8000*1024^2)\n\n  set.seed(314)\n\n  # Randomize block heights to make processing time more uniform between parallel processes\n  block.heights <- split(block.heights, sample(cut(block.heights, threads)))\n  # First randomly put heights into list elements (split() will sort them ascendingly in each list element)\n  block.heights <- lapply(block.heights, sample)\n  # Then order the heights randomly within each list element\n  block.heights <- unname(block.heights)\n\n  returned <- future.apply::future_lapply(block.heights, function(block.heights) {\n\n    url.rpc <- sample(url.rpc, 1)\n\n    handle <- RCurl::getCurlHandle()\n\n    return.data <- vector(\"list\", length(block.heights))\n\n    for (height.iter in seq_along(block.heights)) {\n\n      height <- block.heights[height.iter]\n\n      block.data <- xmr.rpc(url.rpc = paste0(url.rpc, \"/json_rpc\"),\n        method = \"get_block\",\n        params = list(height = height ),\n        keep.trying.rpc = TRUE,\n        curl = handle)$result\n\n      txs.to.collect <- c(block.data$miner_tx_hash, block.data$tx_hashes)\n\n      rcp.ret <- \ttryCatch(RCurl::postForm(paste0(url.rpc, \"/get_transactions\"),\n        .opts = list(\n          postfields = paste0('{\"txs_hashes\":[\"', paste0(txs.to.collect, collapse = '\",\"'), '\"],\"decode_as_json\":true}'),\n          httpheader = c('Content-Type' = 'application/json', Accept = 'application/json')\n        ),\n        curl = handle\n      ), error = function(e) {NULL})\n\n      if (length(rcp.ret) == 0) {\n        while (length(rcp.ret) == 0) {\n          rcp.ret <- tryCatch(RCurl::postForm(paste0(url.rpc, \"/get_transactions\"),\n            .opts = list(\n              postfields = paste0('{\"txs_hashes\":[\"', paste0(txs.to.collect, collapse = '\",\"'), '\"],\"decode_as_json\":true}'),\n              httpheader = c('Content-Type' = 'application/json', Accept = 'application/json')\n            ),\n            curl = handle\n          ), error = function(e) {NULL})\n        }\n      }\n\n      rcp.ret <- RJSONIO::fromJSON(rcp.ret, asText = TRUE)\n\n      output.index.collected <- vector(\"list\", length(txs.to.collect))\n      rings.collected <- vector(\"list\", length(txs.to.collect) - 1)\n\n      for (i in seq_along(txs.to.collect)) {\n\n        tx.json <- tryCatch(\n          RJSONIO::fromJSON(rcp.ret$txs[[i]]$as_json, asText = TRUE),\n          error = function(e) {NULL} )\n\n        if (is.null(tx.json)) {\n          # stop()\n          cat(paste0(\"tx: \", i, \" block: \", height, \"\\n\"), file = \"~/RingCT-problems.txt\", append = TRUE)\n          next\n        }\n\n        output.amounts <- sapply(tx.json$vout, FUN = function(x) {x$amount})\n\n        tx_size_bytes <- ifelse(i == 1,\n          nchar(rcp.ret$txs[[i]]$pruned_as_hex) / 2,\n          nchar(rcp.ret$txs[[i]]$as_hex) / 2)\n        # Coinbase has special structure\n        # Reference:\n        # https://libera.monerologs.net/monero-dev/20221231\n        # https://github.com/monero-project/monero/pull/8691\n        # https://github.com/monero-project/monero/issues/8311\n\n        calc.tx.weight.clawback <- function(p, is.bpp) {\n          pow.of.two <- 2^(1:4)\n          pow.of.two.index <- findInterval(p, pow.of.two, left.open = TRUE) + 1\n\n          n_padded_outputs <- pow.of.two[pow.of.two.index]\n\n          if (is.bpp) {\n            multiplier <- 6\n          } else {\n            multiplier <- 9\n          }\n\n          bp_base <- (32 * (multiplier + 7 * 2)) / 2\n          nlr <- ceiling(log2(64 * p))\n          bp_size <- 32 * (multiplier + 2 * nlr)\n          transaction_clawback <- (bp_base * n_padded_outputs - bp_size) * 4 / 5\n          floor(transaction_clawback) # With bpp, this is sometimes (always?) not an integer\n        }\n        # Equation from page 63 of Zero to Monero 2.0\n        # Updated with Bulletproofs+\n        # https://github.com/monero-project/monero/blame/c8214782fb2a769c57382a999eaf099691c836e7/src/cryptonote_basic/cryptonote_format_utils.cpp#L106\n\n\n        if (length(tx.json$vout) == 2 || i == 1) {\n          # i == 1 means the first tx, which is the coinbase tx\n          tx_weight_bytes <- tx_size_bytes\n        } else {\n          tx_weight_bytes <- tx_size_bytes +\n            calc.tx.weight.clawback(length(tx.json$vout), length(tx.json$rctsig_prunable$bpp) > 0)\n        }\n\n\n        tx_fee <- ifelse(i == 1 || is.null(tx.json$rct_signatures), NA, tx.json$rct_signatures$txnFee)\n        # missing non-RingCT tx fee\n\n        is.mordinal <-\n          height >= 2838965 &&\n          length(tx.json$vout) == 2 &&\n          i > 1 && # not the first tx, which is the coinbase tx\n          length(tx.json$extra) > 44 &&\n          tx.json$extra[45] == 16\n        # With \"&&\", evaluates each expression sequentially until it is false (if ever). Then stops.\n        # If all are TRUE, then returns true.\n\n        is.mordinal.transfer <-\n          height >= 2838965 &&\n          length(tx.json$vout) == 2 &&\n          i > 1 && # not the first tx, which is the coinbase tx\n          length(tx.json$extra) > 44 &&\n          tx.json$extra[45] == 17\n\n        output.index.collected[[i]] <- data.table(\n          block_height = height,\n          block_timestamp = block.data$block_header$timestamp,\n          tx_num = i,\n          tx_hash = txs.to.collect[i],\n          tx_version = tx.json$version,\n          tx_fee = tx_fee,\n          tx_size_bytes = tx_size_bytes,\n          tx_weight_bytes = tx_weight_bytes,\n          number_of_inputs = length(tx.json$vin),\n          number_of_outputs = length(tx.json$vout),\n          output_num = seq_along(rcp.ret$txs[[i]]$output_indices),\n          output_index = rcp.ret$txs[[i]]$output_indices,\n          output_amount = output.amounts,\n          output_unlock_time = tx.json$unlock_time,\n          is_mordinal = is.mordinal,\n          is_mordinal_transfer = is.mordinal.transfer)\n\n\n        if (i == 1L) { next }\n        # Skip first tx since it is the coinbase and has no inputs\n\n        tx_hash <- txs.to.collect[i]\n\n        rings <- vector(\"list\", length(tx.json$vin))\n\n        for (j in seq_along(tx.json$vin)) {\n          rings[[j]] <- data.table(\n            tx_hash = tx_hash,\n            input_num = j,\n            input_amount = tx.json$vin[[j]]$key$amount,\n            key_offset_num = seq_along(tx.json$vin[[j]]$key$key_offsets),\n            key_offsets = tx.json$vin[[j]]$key$key_offsets\n          )\n        }\n\n        rings.collected[[i-1]] <- rbindlist(rings)\n\n      }\n\n      output.index.collected <- data.table::rbindlist(output.index.collected)\n      rings.collected <- rbindlist(rings.collected)\n\n      return.data[[height.iter]] <- list(\n        output.index.collected = output.index.collected,\n        rings.collected = rings.collected)\n\n    }\n\n    return.data\n\n  }, future.seed = TRUE)\n})\n\n\nfuture::plan(future::sequential)\n# Shuts down R threads to free RAM\n\nreturned.temp <- vector(\"list\", length(returned))\n\nfor (i in seq_along(returned)) {\n  returned.temp[[i]] <- list(\n    output.index.collected = rbindlist(lapply(returned[[i]],\n      FUN = function(y) { y$output.index.collected })),\n    rings.collected = rbindlist(lapply(returned[[i]],\n      FUN = function(y) { y$rings.collected }))\n  )\n}\n\nreturned.temp <- list(\n  output.index.collected = rbindlist(lapply(returned.temp,\n    FUN = function(y) { y$output.index.collected })),\n  rings.collected = rbindlist(lapply(returned.temp,\n    FUN = function(y) { y$rings.collected }))\n)\n\noutput.index <- returned.temp$output.index.collected\nreturned.temp$output.index.collected <- NULL\nxmr.rings <- returned.temp$rings.collected\nrm(returned.temp)\n\nsetorder(xmr.rings, tx_hash, input_num, key_offset_num)\n\nxmr.rings[, output_index := cumsum(key_offsets), by = c(\"tx_hash\", \"input_num\")]\n\nxmr.rings <- merge(xmr.rings, unique(output.index[, .(tx_hash, block_height,\n  block_timestamp, tx_fee, tx_size_bytes, tx_weight_bytes, is_mordinal, is_mordinal_transfer)]), by = \"tx_hash\")\n\nring.col.names <- c(\"block_height\", \"block_timestamp\", \"tx_fee\", \"tx_size_bytes\",\n  \"tx_weight_bytes\", \"is_mordinal\", \"is_mordinal_transfer\")\n\nsetnames(xmr.rings, ring.col.names, paste0(ring.col.names, \"_ring\"))\n\noutput.index[, output_amount_for_index := ifelse(tx_num == 1, 0, output_amount)]\n\noutput.index <- output.index[ !(tx_num == 1 & tx_version == 1), ]\n# Remove coinbase outputs that are ineligible for use in a RingCT ring\n# See https://libera.monerologs.net/monero-dev/20230323#c224570\n\nv16.fork.height <- 2689608 # 2022-08-14\nxmr.rings <- xmr.rings[block_height_ring >= v16.fork.height, ]\n# Remove data from before August 2022 hard fork\n\n\nxmr.rings <- merge(xmr.rings, output.index[, .(block_height, block_timestamp, tx_num, output_num,\n  output_index, output_amount, output_amount_for_index, output_unlock_time,\n  is_mordinal, is_mordinal_transfer, tx_fee, tx_size_bytes)],\n  # only dont need tx_hash column from output.index\n  by.x = c(\"input_amount\", \"output_index\"),\n  by.y = c(\"output_amount_for_index\", \"output_index\")) #, all = TRUE)\n\n\nxmr.rings <- xmr.rings[input_amount == 0, ]\n# Remove non-RingCT rings\n\nsetorder(output.index, block_height, tx_num, output_num)\n\n\nxmr.rings.isoweek <- unique(xmr.rings[, .(block_timestamp_ring = block_timestamp_ring)])\n\nxmr.rings.isoweek[, block_timestamp_ring_isoweek := paste0(lubridate::isoyear(as.POSIXct(block_timestamp_ring, origin = \"1970-01-01\", tz = \"UTC\")), \"-\",\n  formatC(lubridate::isoweek(as.POSIXct(block_timestamp_ring, origin = \"1970-01-01\", tz = \"UTC\")), width = 2, flag = \"0\"))]\n\nxmr.rings <- merge(xmr.rings, xmr.rings.isoweek, by = \"block_timestamp_ring\")\n# speed improvement by splitting and then merging\n\niso.weeks <- xmr.rings[, unique(block_timestamp_ring_isoweek)]\n\niso.weeks <- iso.weeks[as.numeric(gsub(\"-\", \"\", iso.weeks, fixed = TRUE)) >= 202233]\n# week after hard fork\n\n\n```\n","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","highlight-style":"gruvbox","html-math-method":"mathml","output-file":"ring-gathering.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.40","bibliography":["references.bib"],"bibliographystyle":"apa","editor":"visual","theme":"superhero","fig-cap-location":"top"},"extensions":{"book":{"multiFile":true}}},"pdf":{"identifier":{"display-name":"PDF","target-format":"pdf","base-format":"pdf"},"execute":{"fig-width":5.5,"fig-height":3.5,"fig-format":"pdf","fig-dpi":300,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"pdf","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"pdf-engine":"xelatex","standalone":true,"variables":{"graphics":true,"tables":true},"default-image-extension":"pdf","to":"pdf","output-file":"ring-gathering.pdf"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"block-headings":true,"bibliography":["references.bib"],"bibliographystyle":"apa","editor":"visual","documentclass":"scrreprt"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","pdf"]}